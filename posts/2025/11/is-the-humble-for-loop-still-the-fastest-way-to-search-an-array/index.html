<!DOCTYPE html>
<html lang="en-us">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Is the Humble For-Loop Still the Fastest Way to Search an Array? | Ivan Pribec</title>
<meta name="title" content="Is the Humble For-Loop Still the Fastest Way to Search an Array?" />
<meta name="description" content="Is the Humble For-Loop the Fastest Way to Search an Array?
Scrolling Twitter (now named X) the other night, I came across the following
provocative programming snippet:
C devs will tell you this is peak API and Programming Languages design,And nothing better has been invented since 1972. pic.twitter.com/mqELKMVEOb&mdash; Dmitrii Kovanikov (@ChShersh) November 20, 2025 
This got me wondering: how fast are &ldquo;modern&rdquo; alternatives?
One of the C&#43;&#43; proponents in the thread suggested the following &ldquo;ultra-modern&rdquo; solution using
C&#43;&#43;23 std::views::enumerate:" />
<meta name="keywords" content="C&#43;&#43;,Fortran,Performance,findloc," />


<meta property="og:url" content="//localhost:1313/posts/2025/11/is-the-humble-for-loop-still-the-fastest-way-to-search-an-array/">
  <meta property="og:site_name" content="Ivan Pribec">
  <meta property="og:title" content="Is the Humble For-Loop Still the Fastest Way to Search an Array?">
  <meta property="og:description" content="Is the Humble For-Loop the Fastest Way to Search an Array? Scrolling Twitter (now named X) the other night, I came across the following provocative programming snippet:
C devs will tell you this is peak API and Programming Languages design,
And nothing better has been invented since 1972. pic.twitter.com/mqELKMVEOb
— Dmitrii Kovanikov (@ChShersh) November 20, 2025 This got me wondering: how fast are “modern” alternatives?
One of the C&#43;&#43; proponents in the thread suggested the following “ultra-modern” solution using C&#43;&#43;23 std::views::enumerate:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-11-22T00:00:00+00:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Fortran">
    <meta property="article:tag" content="Performance">
    <meta property="article:tag" content="Findloc">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Is the Humble For-Loop Still the Fastest Way to Search an Array?">
  <meta name="twitter:description" content="Is the Humble For-Loop the Fastest Way to Search an Array? Scrolling Twitter (now named X) the other night, I came across the following provocative programming snippet:
C devs will tell you this is peak API and Programming Languages design,
And nothing better has been invented since 1972. pic.twitter.com/mqELKMVEOb
— Dmitrii Kovanikov (@ChShersh) November 20, 2025 This got me wondering: how fast are “modern” alternatives?
One of the C&#43;&#43; proponents in the thread suggested the following “ultra-modern” solution using C&#43;&#43;23 std::views::enumerate:">




  <meta itemprop="name" content="Is the Humble For-Loop Still the Fastest Way to Search an Array?">
  <meta itemprop="description" content="Is the Humble For-Loop the Fastest Way to Search an Array? Scrolling Twitter (now named X) the other night, I came across the following provocative programming snippet:
C devs will tell you this is peak API and Programming Languages design,
And nothing better has been invented since 1972. pic.twitter.com/mqELKMVEOb
— Dmitrii Kovanikov (@ChShersh) November 20, 2025 This got me wondering: how fast are “modern” alternatives?
One of the C&#43;&#43; proponents in the thread suggested the following “ultra-modern” solution using C&#43;&#43;23 std::views::enumerate:">
  <meta itemprop="datePublished" content="2025-11-22T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-11-22T00:00:00+00:00">
  <meta itemprop="wordCount" content="2000">
  <meta itemprop="keywords" content="C&#43;&#43;,Fortran,Performance,Findloc">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
    --width: 720px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color: #8b6fcb;
    --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: #01242e;
      --heading-color: #eee;
      --text-color: #ddd;
      --link-color: #8cc2dd;
      --visited-color: #8b6fcb;
      --blockquote-color: #ccc;
    }
  }

  body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
  }

  a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  nav a {
    margin-right: 8px;
  }

  strong,
  b {
    color: var(--heading-color);
  }

  button {
    margin: 0;
    cursor: pointer;
  }

  time {
    font-family: monospace;
    font-style: normal;
    font-size: 15px;
  }

  main {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  hr {
    border: 0;
    border-top: 1px dashed;
  }

  img {
    max-width: 100%;
  }

  code {
    font-family: monospace;
    padding: 2px;
    border-radius: 3px;
  }

  blockquote {
    border-left: 1px solid #999;
    color: var(--blockquote-color);
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px 0;
    text-align: center;
  }

  .title:hover {
    text-decoration: none;
  }

  .title h1 {
    font-size: 1.5em;
  }

  .inline {
    width: auto !important;
  }

  .highlight,
  .code {
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: var(--visited-color);
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Ivan Pribec</h2>
</a>
<nav>
<a href="/posts/">blog</a>

<a href="/code/">code</a>

<a href="/diary/">diary</a>

<a href="/now/">now</a>

</nav>
</header>
  <main>

<content>
  <h2 id="is-the-humble-for-loop-the-fastest-way-to-search-an-array">Is the Humble For-Loop the Fastest Way to Search an Array?</h2>
<p>Scrolling Twitter (now named X) the other night, I came across the following
provocative programming snippet:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">C devs will tell you this is peak API and Programming Languages design,<br><br>And nothing better has been invented since 1972. <a href="https://t.co/mqELKMVEOb">pic.twitter.com/mqELKMVEOb</a></p>&mdash; Dmitrii Kovanikov (@ChShersh) <a href="https://twitter.com/ChShersh/status/1991561035200033182?ref_src=twsrc%5Etfw">November 20, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>This got me wondering: how fast <em>are</em> &ldquo;modern&rdquo; alternatives?</p>
<p>One of the C++ proponents in the thread suggested the following &ldquo;ultra-modern&rdquo; solution using
C++23 <a href="https://en.cppreference.com/w/cpp/ranges/enumerate_view.html"><code>std::views::enumerate</code></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> find(std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> items, <span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> [i, value] <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>views<span style="color:#f92672">::</span>enumerate(items)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>nullopt;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;m a big fan of structured bindings available since C++17. They can lead to code which is easier to read. Some <a href="https://www.reedbeta.com/blog/python-like-enumerate-in-cpp17/">quick searching</a> shows that an <code>enumerate</code>-like solution was possible already in C++17, but it is nice to know this is now part of the standard.</p>
<p>One benefit of using <a href="https://en.cppreference.com/w/cpp/utility/optional.html"><code>std::optional</code></a> for the return value is you can use the full range <code>size_t</code> for the returned index.
In the C approach, an empty array or absence of the item would be indicated by a negative value.
This implies the use of a signed integer type for the result, which limits the range.
The difference matters if you need to search more than <code>2^31 - 1</code> elements.
In the types of problems I deal with, this wouldn&rsquo;t be a problem.</p>
<p>The second benefit of <code>std::optional</code> is the result can be used as a boolean:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> res <span style="color:#f92672">=</span> find(items,<span style="color:#ae81ff">42</span>)) {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found element 42 at index &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>res <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The item contained in the <code>std::optional</code> class template (i.e. the index) is accessed using the familiar dereference operator.</p>
<p>With the C-like solution you&rsquo;d need to store the result first, and then use it
in one of two ways:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#75715e">// store result and check condition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> idx <span style="color:#f92672">=</span> find(items,<span style="color:#ae81ff">10000</span>,<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// using C++17 init-statement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> idx <span style="color:#f92672">=</span> find(items,<span style="color:#ae81ff">10000</span>,<span style="color:#ae81ff">42</span>); idx <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">/* ... */</span> }
</span></span></code></pre></div><p>Both are more verbose than using <code>std::optional</code>, and it&rsquo;s easy to introduce mistakes.
If we accidentally use <code>idx</code> as the condition, it will get converted to a boolean!</p>
<p>If we limit ourselves to C++20, there are a couple other idiomatic alternatives in C++.
The first would be the classic iterator based approach:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Iter find_iter(Iter begin, Iter end, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (Iter it <span style="color:#f92672">=</span> begin; it <span style="color:#f92672">!=</span> end; <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>it <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">return</span> it;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> end;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Another option is to use a range-based for loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> find_rbfor(std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">&gt;</span> items, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> v : items) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>distance(items.data(), <span style="color:#f92672">&amp;</span>v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>nullopt;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We could also do away with looping and just use the <code>std::find</code> algorithm from STL:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> find_find(std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">&gt;</span> items, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>ranges<span style="color:#f92672">::</span>find(items, x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> items.end()) <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>nullopt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>ranges<span style="color:#f92672">::</span>distance(items.begin(), it);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example shows one of the difficulties I find personally when working with C++.
There are often many competing ways to solve the same problem.
I suppose as long as the code works correctly and the client code is clean any of
the implementations will do.
Still, it takes time and effort to develop a good intuition for what is the best one.
I only use C++ here and there.</p>
<p>API elegance aside; performance often tells a different story.</p>
<h3 id="searching-a-double-array">Searching a <code>double</code> array</h3>
<p>Now when it comes to performance, things are not as straightforward.
Most CPUs today have some level of SIMD capabilities and it would be nice to know
if they are used.
For this purpose I prepared a micro-benchmark using the Google Benchmark framework.
The benchmark can be found in my <a href="https://codeberg.org/ivan-pi/shed/src/branch/main/perf">&ldquo;shed&rdquo; of code snippets</a>.</p>
<p>For the sake of the experiment, we&rsquo;ll scan an array of doubles of size 32768 (<code>2^15</code>), searching for the last element.
The resulting time needed is measured on an Apple M2 Pro.</p>
<p>Using GCC 15.2 I got:</p>
<table>
  <thead>
      <tr>
          <th>Variant</th>
          <th>Time (ns)</th>
          <th>Bandwidth (GiB/s)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>C-like</td>
          <td>5036</td>
          <td>50.0</td>
      </tr>
      <tr>
          <td>Iterators</td>
          <td>10084</td>
          <td>24.6</td>
      </tr>
      <tr>
          <td>Range-based for</td>
          <td>10705</td>
          <td>24.2</td>
      </tr>
      <tr>
          <td><code>find</code> algorithm</td>
          <td>9847</td>
          <td>25.0</td>
      </tr>
  </tbody>
</table>
<p>Using Apple clang version 17 I got:</p>
<table>
  <thead>
      <tr>
          <th>Variant</th>
          <th>Time (ns)</th>
          <th>Bandwidth (GiB/s)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>C-like</td>
          <td>10342</td>
          <td>24.0</td>
      </tr>
      <tr>
          <td>Iterators</td>
          <td>9656</td>
          <td>25.4</td>
      </tr>
      <tr>
          <td>Range-based for</td>
          <td>10443</td>
          <td>23.6</td>
      </tr>
      <tr>
          <td><code>find</code> algorithm</td>
          <td>10074</td>
          <td>24.6</td>
      </tr>
  </tbody>
</table>
<p>In both cases I compiled the benchmark driver with <code>-O3 -mcpu=native</code>.
If you&rsquo;re not interested in assembly dumps, feel free to skim through the next few paragraphs.</p>
<p>As we can see, with gcc the C-like loop is the fastest.
Looking into the generated assembly in <a href="https://godbolt.org/z/9v9oTPbM1">Compiler Explorer</a>,
the C-like variant in GCC gives the following innermost loop:</p>
<pre tabindex="0"><code>.L7:
        add     v29.4s, v29.4s, v27.4s
        cmp     x3, x2
        beq     .L34
.L9:
        ldp     q31, q30, [x2], 32
        fcmeq   v31.2d, v31.2d, v28.2d
        fcmeq   v30.2d, v30.2d, v28.2d
        orr     v31.16b, v31.16b, v30.16b
        umaxp   v31.4s, v31.4s, v31.4s
        fmov    x5, d31
        cbz     x5, .L7
</code></pre><p>Here GCC uses 4-way unrolling of the loop and uses vector comparisons, which explains the speed.</p>
<p>The other variants appear to use 2-way unrolling - a possible explanation for the 2x difference:</p>
<pre tabindex="0"><code>.L40:
        add     v30.2d, v30.2d, v28.2d
        cmp     x5, x1
        beq     .L55
.L43:
        lsl     x2, x1, 4
        add     x1, x1, 1
        ldr     q31, [x4, x2]
        fcmeq   v31.2d, v31.2d, v29.2d
        umaxp   v31.4s, v31.4s, v31.4s
        fmov    x2, d31
        cbz     x2, .L40
</code></pre><p>With <code>clang</code> on the other hand, all variants use loop nests with scalar instructions:</p>
<pre tabindex="0"><code>.LBB0_3:
        ldr     d1, [x8, x0, lsl #3]
        fcmp    d1, d0
        b.eq    .LBB0_6
        add     x0, x0, #1
        cmp     x9, x0
        b.ne    .LBB0_3
</code></pre><p>I was interested in what the Intel C++ Compiler (the newer LLVM-based version) would do.
Interestingly, only the C-like variant appears to be vectorized.
For example targetting the Skylake architecture (<code>-march=skylake</code>), it produces a rather aggresively vectorized loop:</p>
<pre tabindex="0"><code>.LBB0_16:
        lea     rbx, [r11 + 8*r9]
        vcmpeqpd        ymm2, ymm1, ymmword ptr [rbx]
        vcmpeqpd        ymm3, ymm1, ymmword ptr [rbx + 32]
        vpackssdw       ymm2, ymm2, ymm3
        vcmpeqpd        ymm3, ymm1, ymmword ptr [rbx + 64]
        vpermq  ymm2, ymm2, 216
        vcmpeqpd        ymm4, ymm1, ymmword ptr [rbx + 96]
        vpackssdw       ymm3, ymm3, ymm4
        vpermq  ymm3, ymm3, 216
        vpackssdw       ymm2, ymm2, ymm3
        vpermq  ymm2, ymm2, 216
        vcmpeqpd        ymm3, ymm1, ymmword ptr [rbx + 128]
        vcmpeqpd        ymm4, ymm1, ymmword ptr [rbx + 160]
        vpackssdw       ymm3, ymm3, ymm4
        vpermq  ymm3, ymm3, 216
        vcmpeqpd        ymm4, ymm1, ymmword ptr [rbx + 192]
        vcmpeqpd        ymm5, ymm1, ymmword ptr [rbx + 224]
        vpackssdw       ymm4, ymm4, ymm5
        vpermq  ymm4, ymm4, 216
        vpackssdw       ymm3, ymm3, ymm4
        vpermq  ymm3, ymm3, 216
        vpacksswb       ymm2, ymm2, ymm3
        vpmovmskb       ebx, ymm2
        test    ebx, ebx
        jne     .LBB0_17
        add     r9, 32
        cmp     r9, r10
        jbe     .LBB0_16
</code></pre><p>Here it works 32 of elements as inferred from the the 8 memory references and 4 doubles per YMM register.</p>
<p>I did not attempt to measure the performance on an AMD64 machine.</p>
<h4 id="fortran-findloc-intrinsic">Fortran <code>findloc</code> intrinsic</h4>
<p>Fortran 2008 offers a built-in function, <code>findloc</code>, which makes code very clear and concise.
It is generic over intrinsic types and also provides several optional arguments:</p>
<pre tabindex="0"><code>result = findloc(array, value, dim [, mask] [,kind] [,back])
</code></pre><p>But conciseness isn&rsquo;t everything - what about performance?</p>
<p>To test this, we can wrap the intrinsic in a short C-compatible wrapper function, allowing it to be called from C or C++:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fortran" data-lang="fortran"><span style="display:flex;"><span><span style="color:#75715e">! int find_fortran(double items[], int size, double item);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> find_fortran(items, size, item) <span style="color:#66d9ef">bind</span>(c)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span>, <span style="color:#66d9ef">intrinsic</span> <span style="color:#66d9ef">::</span> iso_c_binding
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implicit</span> <span style="color:#66d9ef">none</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">integer</span>(<span style="color:#66d9ef">c_int</span>), <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">::</span> size
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">intent</span>(in) <span style="color:#66d9ef">::</span> items(size)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">intent</span>(in), <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">::</span> item
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">integer</span>(<span style="color:#66d9ef">c_int</span>) <span style="color:#66d9ef">::</span> find_fortran
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">! Note: Fortran uses 1-based indexing by default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    find_fortran <span style="color:#f92672">=</span> findloc(items,item,dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span> <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>One difference to C and C++ is since Fortran uses 1-based indexing by default,
the convention in Fortran is to use 0 to indicate absence of the item.
Hence we need to subtract one to match the convention used earlier.</p>
<p>For completeness we will also look at a loop-based version in Fortran.
For theatrical purposes, I&rsquo;m writing it in legacy fixed-form Fortran complete with implicit typing and line numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fortran" data-lang="fortran"><span style="display:flex;"><span>C     DFIND <span style="color:#f92672">-</span> FIND ITEM IN <span style="color:#66d9ef">ARRAY</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">INTEGER</span> <span style="color:#66d9ef">FUNCTION</span> DFIND(ITEMS, N, X)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">DOUBLE PRECISION</span> ITEMS(N), X
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">DO</span> <span style="color:#ae81ff">10</span> I <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, N
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">IF</span> (X .EQ. ITEMS(I)) <span style="color:#66d9ef">THEN</span>
</span></span><span style="display:flex;"><span>            DFIND <span style="color:#f92672">=</span> I
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">RETURN</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">ENDIF</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">CONTINUE</span>
</span></span><span style="display:flex;"><span>C     ITEM NOT FOUND
</span></span><span style="display:flex;"><span>      DFIND <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">RETURN</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">END</span>
</span></span></code></pre></div><p>This time we have to rely on the platform calling convention to call the routine from C++.
We can achieve this with the following prototype:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cxx" data-lang="cxx"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">int</span> dfind_(<span style="color:#66d9ef">double</span> items[], <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>n, <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>x);
</span></span></code></pre></div><p>For the tests we&rsquo;ll be using gfortran 15.2 and flang 20.1, and using the flags: <code>-O3 -mcpu=apple-m2</code>.</p>
<p>The performance results look the following:</p>
<table>
  <thead>
      <tr>
          <th>Compiler</th>
          <th>Time (ns)</th>
          <th>Bandwidth (GiB/s)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>gfortran <code>findloc</code></td>
          <td>10422</td>
          <td>24.1</td>
      </tr>
      <tr>
          <td>gfortran <code>DFIND</code></td>
          <td>4891</td>
          <td>50.0</td>
      </tr>
      <tr>
          <td>flang <code>findloc</code></td>
          <td>48566</td>
          <td>5.0</td>
      </tr>
      <tr>
          <td>flang <code>DFIND</code></td>
          <td>9998</td>
          <td>24.4</td>
      </tr>
  </tbody>
</table>
<p>With gfortran the performance is comparable to the previous GCC results.
Once again, the difference between <code>findloc</code> and raw loops is probably due to the implicit compiler choice between 2-way and 4-way unrolling.
It would be interesting to figure out what compilation or language factor leads to this difference.</p>
<p>On the other hand flang&rsquo;s <code>findloc</code> implementations proves to be slower.
We can look for an explanation for the low performance by peeking into the assembly.
Unlike gfortran, which inlines <code>findloc</code>, flang calls a runtime function (<code>__FortranAFindlocDim</code>).
The implementation of this function can be found in the <a href="https://github.com/llvm/llvm-project/blob/2e424deeb6180d112323f4df955c8034eb56780c/flang-rt/lib/runtime/findloc.cpp#L317">LLVM repository</a>.
For the record, I&rsquo;m using flang installed via the <code>brew</code> package manager.
Maybe some LLVM compilation tweaks could improve the performance of this routine?
Hopefully this will improve in future versions.</p>
<p>For completeness, I also looked at the output of the Intel Fortran compilers.
Neither ifort 2021.11 (the last pre-deprecation release) nor ifx 2024.0.0 vectorize the loop, and use scalar instructions instead.</p>
<p>So if you need a fast search over an array of doubles, and performance is the priority, a straightforward hand-written loop remains an efficient option. It may not be the peak of API or programming language design, but it gets the job done.</p>
<h3 id="searching-an-int-array">Searching an <code>int</code> array</h3>
<p>The original discussion on Twitter concerned an integer array, so I ran the same micro-benchmarks for <code>int</code> as well.
In this scenario there is less variation across C++ variants.</p>
<p>Integer search using GCC 15.2:</p>
<table>
  <thead>
      <tr>
          <th>Variant</th>
          <th>Time (ns)</th>
          <th>Bandwidth (GiB/s)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>C-like</td>
          <td>4840</td>
          <td>25.2</td>
      </tr>
      <tr>
          <td>Iterators</td>
          <td>4863</td>
          <td>25.1</td>
      </tr>
      <tr>
          <td>Range-based for</td>
          <td>4909</td>
          <td>24.9</td>
      </tr>
      <tr>
          <td><code>find</code> algorithm</td>
          <td>4899</td>
          <td>24.9</td>
      </tr>
      <tr>
          <td>Fortran <code>findloc</code></td>
          <td>4834</td>
          <td>25.3</td>
      </tr>
      <tr>
          <td>Fortran <code>ÌFIND</code></td>
          <td>4801</td>
          <td>25.4</td>
      </tr>
  </tbody>
</table>
<p>Integer search using clang 17.0 and flang 20.1:</p>
<table>
  <thead>
      <tr>
          <th>Variant</th>
          <th>Time (ns)</th>
          <th>Bandwidth (GiB/s)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>C-like</td>
          <td>9690</td>
          <td>12.6</td>
      </tr>
      <tr>
          <td>Iterators</td>
          <td>9972</td>
          <td>12.4</td>
      </tr>
      <tr>
          <td>Range-based for</td>
          <td>11138</td>
          <td>11.9</td>
      </tr>
      <tr>
          <td><code>find</code> algorithm</td>
          <td>9932</td>
          <td>12.3</td>
      </tr>
      <tr>
          <td>Fortran <code>findloc</code></td>
          <td>49764</td>
          <td>2.5</td>
      </tr>
      <tr>
          <td>Fortran <code>ÌFIND</code></td>
          <td>9913</td>
          <td>12.3</td>
      </tr>
  </tbody>
</table>
<p>With both compiler families the C-like solution happened to be a tiny fraction faster.
I didn&rsquo;t inspect the generated assembly this time, but the differences are small enough to be considered negligible.
As before, the <code>findloc</code> implementation in flang continues to lag behind others.</p>
<h3 id="replicating-the-results">Replicating the results</h3>
<p>As mentioned earlier, the code can be found in the <a href="https://codeberg.org/ivan-pi/shed/src/branch/main/perf"><code>shed/perf</code> folder</a>.</p>
<p>It is also possible to download a standalone tarball <a href="https://codeberg.org/ivan-pi/shed/archive/main:perf.tar.gz">here (.tar.gz, 12.4 KB)</a>. Unpack the files using:</p>
<pre tabindex="0"><code>tar xf shed-main_perf.tar.gz &amp;&amp; cd shed
</code></pre><p>Create the build directory and configure the CMake project with your desired options:</p>
<pre tabindex="0"><code>mkdir build &amp;&amp; cd build
cmake .. -DCMAKE_Fortran_COMPILER=gfortran -DCMAKE_Fortran_FLAGS=&#34;-O3 -mcpu=native&#34; -DCMAKE_C_COMPILER=gcc-15 -DCMAKE_C_FLAGS=&#34;-O3 -mcpu=native&#34; -DCMAKE_CXX_COMPILER=g++-15 -DCMAKE_CXX_FLAGS=&#34;-O3 -mcpu=native&#34; -DCMAKE_BUILD_TYPE=Release
</code></pre><p>If that succeeds, you can build the executable and run the benchmark driver with:</p>
<pre tabindex="0"><code>make findloc
./findloc --benchmark_filter=32768
</code></pre><p>The raw output will look similar to this:</p>
<pre tabindex="0"><code>2025-11-22T20:38:38+01:00
Running ./findloc
Run on (10 X 24.0006 MHz CPU s)
CPU Caches:
  L1 Data 64 KiB
  L1 Instruction 128 KiB
  L2 Unified 4096 KiB (x10)
Load Average: 193.07, 174.62, 183.12
------------------------------------------------------------------------------------
Benchmark                          Time             CPU   Iterations UserCounters...
------------------------------------------------------------------------------------
BM_find_fortran/32768          10330 ns        10020 ns        69115 bytes_per_second=24.3652Gi/s
BM_find_dfind/32768             4914 ns         4909 ns       141821 bytes_per_second=49.7352Gi/s
BM_find_c/32768                 4855 ns         4855 ns       143112 bytes_per_second=50.2876Gi/s
BM_find_iter/32768              9760 ns         9754 ns        71777 bytes_per_second=25.0292Gi/s
BM_find_rbfor/32768             9756 ns         9747 ns        70924 bytes_per_second=25.0469Gi/s
BM_find_range/32768             9795 ns         9791 ns        72052 bytes_per_second=24.9351Gi/s
BM_find_int_fortran/32768       4853 ns         4853 ns       143246 bytes_per_second=25.1543Gi/s
BM_find_int_ifind/32768         4838 ns         4837 ns       144714 bytes_per_second=25.235Gi/s
BM_find_int_c/32768             4854 ns         4850 ns       143823 bytes_per_second=25.1675Gi/s
BM_find_int_iter/32768          4851 ns         4850 ns       142512 bytes_per_second=25.1686Gi/s
BM_find_int_rbfor/32768         4834 ns         4832 ns       144733 bytes_per_second=25.2625Gi/s
BM_find_int_range/32768         5175 ns         5010 ns       100000 bytes_per_second=24.3661Gi/s
``
</code></pre>
</content>



<p>
  
  <a href="//localhost:1313/tags/c&#43;&#43;/">#C&#43;&#43;</a>
  
  <a href="//localhost:1313/tags/fortran/">#Fortran</a>
  
  <a href="//localhost:1313/tags/performance/">#Performance</a>
  
  <a href="//localhost:1313/tags/findloc/">#Findloc</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

  
</body>

</html>
